<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="机器学习,分类,决策树,回归," />





  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml" />






<meta name="description" content="决策树决策树（decision tree）是一种基本的分类与回归方法。决策树模型呈树状结构，在分类问题中，表示基于特征对实例进行分类的过程。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。决策树学习通常包括3个过程：特征选择、决策树的生成、决策树的修剪。">
<meta name="keywords" content="机器学习,分类,决策树,回归">
<meta property="og:type" content="article">
<meta property="og:title" content="决策树">
<meta property="og:url" content="http://yoursite.com/2018/04/09/决策树/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="决策树决策树（decision tree）是一种基本的分类与回归方法。决策树模型呈树状结构，在分类问题中，表示基于特征对实例进行分类的过程。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。决策树学习通常包括3个过程：特征选择、决策树的生成、决策树的修剪。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%911.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%912.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%913.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%914.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%915.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%916.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%917.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%918.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%919.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%9110.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%9111.png">
<meta property="og:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%9112.png">
<meta property="og:updated_time" content="2018-04-18T01:03:17.349Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="决策树">
<meta name="twitter:description" content="决策树决策树（decision tree）是一种基本的分类与回归方法。决策树模型呈树状结构，在分类问题中，表示基于特征对实例进行分类的过程。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。决策树学习通常包括3个过程：特征选择、决策树的生成、决策树的修剪。">
<meta name="twitter:image" content="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%911.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/09/决策树/"/>





  <title>决策树 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/09/决策树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KaiQiang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">决策树</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T16:47:16+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树（decision tree）是一种基本的分类与回归方法。决策树模型呈树状结构，在分类问题中，表示基于特征对实例进行分类的过程。<br>学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。<br>决策树学习通常包括3个过程：<strong>特征选择</strong>、<strong>决策树的生成</strong>、<strong>决策树的修剪</strong>。<br><a id="more"></a></p>
<h2 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><p><strong>决策树</strong>：分类决策树是一种描述对实例进行分类的树形结构。决策树由节点和有向边组成。节点有两种类型：内部节点（internal node）和叶节点（leaf node），内部节点表示一个特征或属性，叶节点表示一个类。<br>用决策树分类，从根节点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子节点；此时，每一个子节点对应着该特征的一个取值。如此递归地对实例进行测试并匹配，直至达到叶节点，最后将实例分到叶节点的类中。<br>决策树示意图，圆和方框分别表示内部节点和叶节点：<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%911.png" alt="此处输入图片的描述"></p>
<h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习本质上是从训练数据集中归纳出一组分类规则，与训练数据集不相矛盾的决策树（即能对训练数据进行正确分类的决策树）可能有多个，也可能一个没有。我们需要的是一个与训练数据矛盾较小的决策树，同时具有很好的泛化能力。从另一个角度看，决策树学习是由训练数据集估计条件概率模型，基于特征空间划分的类的条件概率模型有无穷多个，选择的条件概率模型应该不仅对训练数据有很好的拟合，而且对未知数据有很好的预测。<br>决策树学习用<strong>损失函数</strong>表示这一目标，决策树学习的损失函数通常是<strong>正则化的极大似然函数</strong>，决策树学习的策略是以损失函数为目标函数的最小化。<br>当损失函数确定后，学习问题就变为在损失函数意义下选择最优决策树的问题。从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树学习算法通常采用启发式方法，近似求解这一最优问题，得到的决策树是次优的。<br>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好分类的过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%912.png" alt="此处输入图片的描述"><br>在决策树的基本算法中，有三种情形会导致递归返回：</p>
<ol>
<li>当前节点包含的样本全属于同一类别，无需划分；</li>
<li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分。此时，我们把当前节点标记为叶节点，并将其类别设定为该节点所含样本最多的类别；</li>
<li>当前节点包含的样本集合为空，不能划分。我们同样把当前节点标记为叶节点，但将其类别设定为其父节点所含样本最多的类别。</li>
</ol>
<p>上述方法生成的决策树可能对训练数据有很好的划分能力，但对未知的测试数据却未必有很好的划分能力，即可能发生过拟合现象。这时需要对已生成的决策树自下而上进行<strong>剪枝</strong>，将树变得简单，从而使它具有更好的泛化能力。具体地，就是去掉过于细分的叶节点，使其回退到父节点，甚至更高的节点，然后将父节点或更高的节点改为新的叶节点。<br>如果特征数量很多，也可以在决策树学习开始的时候，对特征进行选择，留下对训练数据有足够分类能力的特征。<br>决策树的生成对应模型的局部选择，决策树的剪枝则考虑全局最优。  </p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>决策树学习的关键是如何选择最优的划分属性，我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即节点的“纯度”越来越高。  </p>
<h3 id="纯度"><a href="#纯度" class="headerlink" title="纯度"></a>纯度</h3><p>我们定义非纯度 $IM(ImpurityMeasure)$ 作为衡量度量类别划分优劣的标准，$IM$ 定义应该满足以下两点：<br>$IM$ 最大时，当前的划分应使所有数据占各类别的比例相等：<br>$p = \frac {1} {number\;of\;classes}$<br>$IM$ 最小时为 0，当前的划分使所有数据都是相同类，这也是我们的<strong>期望目标</strong>。<br>$IM$  在不同的算法中有着不同的度量方式，较为典型的就是熵度量和基尼度量。以下信息增益(越大越好)和信息增益比(越大越好)为熵度量，基尼指数(越小越好)为基尼度量。</p>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>首先给出熵和条件熵的定义。<br>在信息论和概率统计中，熵（entropy）是表示随机变量不确定性的度量。设$X$是一个取有限个值的离散随机变量，其概率分布为</p>
<script type="math/tex; mode=display">P(X=x_i) = p_i, \quad i=1,2,\cdots,n</script><p>则随机变量$X$的熵定义为</p>
<script type="math/tex; mode=display">H(X) = - \sum_{i=1}^n p_i \log p_i</script><p>在上式中，若$p_i = 0$，则定义$0 \log 0 = 0$。通常，上式中的对数以2为底或以e为底，这时熵的单位分别称为比特（bit）或纳特（nat）。由定义可知，熵只依赖于$X$的分布，而与$X$的取值无关，所以也可将$X$的熵记作$H(p)$，即</p>
<script type="math/tex; mode=display">H(p) = - \sum_{i=1}^n p_i \log p_i</script><p>熵越大，随机变量的不确定性就越大，从定义可验证</p>
<script type="math/tex; mode=display">0 \leq H(p) \leq \log n</script><p>当随机变量只取两个值，例如1，0时，即$X$的分布为</p>
<script type="math/tex; mode=display">P(X=1)=p, \quad P(X=0)=1-p, \quad 0 \leq p \leq 1</script><p>熵为</p>
<script type="math/tex; mode=display">H(p) = -p \log_2 p - (1-p) \log_2 (1-p)</script><p>这时，熵$H(p)$随概率$p$变化的曲线如下图所示（单位为比特）：<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%913.png" alt="此处输入图片的描述"><br>当$p=0$或$p=1$时$H(p)=0$，随机变量完全没有不确定性，当$p=0.5$时，$H(p)=1$，熵取值最大，随机变量不确定性最大。<br>设有随机变量$(X,Y)$，其联合概率分布为</p>
<script type="math/tex; mode=display">P(X=x_i,Y=y_i) = p_{ij}, \quad i=1,2,\cdots,n; \quad j=1,2,\cdots,m</script><p>条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性。随机变量$X$给定的条件下随机变量$Y$的条件熵（conditional entropy）$H(Y|X)$，定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望</p>
<script type="math/tex; mode=display">H(Y|X) = \sum_{i=1}^n p_i H(Y|X=x_i)</script><p>其中$p_i = P(X=x_i), \quad i = 1,2,\cdots,n$。<br>当熵和条件熵的概率由数据估计（特别是极大似然估计）得到时，所对应的熵与条件熵分别称为经验熵（empirical entropy）和经验条件熵（empirical conditional entropy）。如果有0概率，令$0 \log 0 = 0$。<br>信息增益（information gain）表示得到特征$X$的信息而使得类$Y$的信息不确定性减少的程度。<br><strong>信息增益</strong>：特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为集合$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，即</p>
<script type="math/tex; mode=display">g(D,A) = H(D) - H(D|A)</script><p>通常，熵$H(Y)$与条件熵$H(Y|X)$之差称为<strong>互信息</strong>（mutual information）。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。<br>决策树学习应用信息增益准则选择特征。给定训练数据集$D$和特征$A$，经验熵$H(D)$表示对数据集$D$进行分类的不确定性。而经验条件熵$H(D|A)$表示在特征$A$给定的条件下对数据集$D$进行分类的不确定性。它们的差为信息增益，表示由于特征$A$而使得对数据集$D$的分类的不确定性减少的程度。显然，对于数据集$D$而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。<br>根据信息增益准则的特征选择方法：对训练数据集（或子集）$D$，计算其每个特征的信息增益，比较它们的大小，选择信息增益最大的特征。<br><strong>信息增益的算法</strong>：<br>输入：训练数据集$D$和特征$A$；<br>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$。<br>（1）计算数据集$D$的经验熵$H(D)$</p>
<script type="math/tex; mode=display">H(D) = - \sum_{k=1}^K \frac{|C_k|}{|D|} \log_2 \frac{|C_k|}{|D|}</script><p>（2）计算特征$A$对数据集$D$的经验条件熵$H(D|A)$</p>
<script type="math/tex; mode=display">H(D|A)= \sum_{i=1}^n \frac{|D_i|}{|D|} H(D_i) = - \sum_{i=1}^n \frac{|D_i|}{|D|} \sum_{k=1}^K \frac{|D_{ik}|}{|D_i|} \log_2 \frac{|D_{ik}|}{|D_i|}</script><p>（3）计算信息增益</p>
<script type="math/tex; mode=display">g(D,A) = H(D) - H(D|A)</script><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><p>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。使用信息增益比（information gain ratio）可以对这一问题进行校正，这也是特征选择的另一准则。<br><strong>信息增益比</strong>：特征$A$对训练数据集$D$的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比，即</p>
<script type="math/tex; mode=display">g_R(D,A) = \frac{g(D,A)}{H_A(D)}</script><p>其中，$H<em>A(D) = -\sum</em>{i=1}^n \frac{|D_i|}{|D|} \log_2 \frac{|D_i|}{|D|}$，$n$是特征$A$取值的个数。  </p>
<h3 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h3><p><strong>基尼指数</strong>：分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数定义为</p>
<script type="math/tex; mode=display">Gini(p) = \sum_{k=1}^K p_k (1 - p_k) = 1 - \sum_{k=1}^K p_k^2</script><p>对于二分类问题，若样本点属于第1个类的概率是$p$，则概率分布的基尼指数为</p>
<script type="math/tex; mode=display">Gini(p) = 2p(1-p)</script><p>对于给定的样本集合$D$，其基尼指数为</p>
<script type="math/tex; mode=display">Gini(D) = 1 - \sum_{i=1}^K (\frac{|C_k|}{|D|})^2</script><p>上式中，$C_k$是$D$中属于第$k$类的样本子集，$K$是类的个数。<br>如果样本集合$D$根据特征$A$是否取某一可能值$a$被分割成$D_1$和$D_2$两部分，即</p>
<script type="math/tex; mode=display">D_1 = \{(x,y) \in D | A(x) = a \}, \quad D_2 = D - D_1</script><p>则在特征$A$的条件下，集合$D$的基尼指数定义为</p>
<script type="math/tex; mode=display">Gini(D,A) = \frac{|D_i|}{|D|} Gini(D_1) + \frac{|D_2|}{|D|} Gini(D_2)</script><p>基尼指数$Gini(D)$表示集合$D$的不确定性，基尼指数$Gini(D,A)$表示经$A=a$分割后集合$D$的不确定性。基尼指数越大，样本集合的不确定性也就越大，这一点与熵相似。<br>下图显示二类问题中基尼指数$Gini(p)$、熵（单位比特）之半$\frac{1}{2}H(p)$和分类误差率的关系。横坐标表示概率$p$，纵坐标表示损失。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%914.png" alt="此处输入图片的描述"></p>
<h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>决策树生成算法递归地产生决策树，这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没那么准确，即出现了过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树，解决此问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。<br>在决策树学习中将已生成的树进行简化的过程成为<strong>剪枝</strong>（pruning）。剪枝从已生成的树上裁掉一些子树或叶节点，并将其根节点或父节点作为新的叶节点，建华分类树模型。<br>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。设树$T$的叶节点个数为$|T|$，$t$是树$T$的叶节点，该叶节点有$N<em>t$个样本点，其中$k$类的样本点有$N</em>{tk}$个，$k=1,2,\cdots,K$，$H_t(T)$为叶节点$t$上的经验熵，$\alpha \geq 0$为参数，则决策树学习的损失函数可以定义为</p>
<script type="math/tex; mode=display">C_\alpha (T) = \sum_{t=1}^{|T|} N_t H_t(T) + \alpha |T|</script><p>其中经验熵为</p>
<script type="math/tex; mode=display">H_t(T) = - \sum_k \frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t}</script><p>损失函数中，有段第一项记为</p>
<script type="math/tex; mode=display">C(T) = \sum_{t=1}^{|T|} N_t H_t(T) = - \sum_{t=1}^{|T|} \sum_{k=1}^K N_{tk} \log \frac{N_{tk}}{N_t}</script><p>此时损失函数可写为</p>
<script type="math/tex; mode=display">C_\alpha(T) = C(T) + \alpha |T|</script><p>上式中，$C(T)$表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，$|T|$表示模型复杂度，参数$\alpha \geq 0$控制两者之间的影响。较大的$\alpha$促使选择较简单的模型，较小的$\alpha$促使选择较复杂的模型。$\alpha = 0$意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。<br>当$\alpha$值确定时，子树越大，往往与训练数据的拟合越好，但是模型的复杂度就越高；相反，子树越小，模型的复杂度就越低，但是往往与训练数据的拟合不好。损失函数正好表示对两者的平衡。<br>决策树生成只考虑了通过提高信息增益（信息增益比）对训练数据进行更好的拟合。而决策树剪枝通过优化损失函数还考虑了减小模型的复杂度。决策树生成学习局部的模型，而决策树剪枝学习整体的模型。<br>利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。<br> <img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%915.png" alt="此处输入图片的描述"></p>
<p>公式（5.15）只需考虑两个树的损失函数的差，其计算可以在局部进行。所以，决策树的剪枝算法可以有一种动态规划的算法实现。<br>周志华的《机器学习》一书中对于决策树剪枝策略的介绍分为预剪枝和后剪枝。预剪枝是指在决策树生成过程中，对每个节点在划分前先进行估计，若当前节点的划分不能带来决策树泛化性能的提升，则停止划分并将当前节点标记为叶节点；后剪枝则是先从训练集生成一颗完整的决策树，然后自底向上地对非叶节点进行考察，若该节点对应的子树替换为叶节点能带来决策树泛化性能提升，则将该子树替换为叶节点。其中泛化能力是用验证集上的准确度进行估计。  </p>
<h2 id="连续值与缺失值"><a href="#连续值与缺失值" class="headerlink" title="连续值与缺失值"></a>连续值与缺失值</h2><h3 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h3><p>现实学习任务中常会遇到连续属性，由于连续属性的可取值数目不在有限，因此，不能直接根据连续属性的可取值来对节点进行划分，此时需要借助连续属性离散化技术。最简单的策略是采用二分法对连续属性进行处理，这也是C4.5决策树算法中采用的机制。<br>给定样本集$D$和连续属性$a$，假定$a$在$D$上出现了$n$个不同的取值，将这些值从小到大进行排序，记为${a^1, a^2, \cdots, a^n}$。基于划分点$t$可将$D$分为子集$D_t^-$和$D_t^+$，其中$D_t^-$包含那些在属性$a$上取值不大于$t$的样本，而$D_t^+$则包含那些在属性$a$上取值大于$t$的样本。显然，对相邻的属性取值$a^i$与$a^{i+1}$来说，$t$在区间$[a^i,a^{i+1})$中取任意值所产生的划分结果相同。因此，对连续属性$a$，可考察包含$n-1$个元素的候选划分点集合</p>
<script type="math/tex; mode=display">T_a = \{ \frac{a^i + a^{i+1}}{2} | 1 \leq i \leq n-1\}</script><p>即把区间$[a^i,a^{i+1})$的中位点$\frac{a^i + a^{i+1}}{2}$作为候选划分点。然后就可以像离散属性值一样考察这些划分点，选取最优的划分点进行样本集合的划分：</p>
<script type="math/tex; mode=display">\begin{align}
    Gain(D,a) &= \max_{t \in T_a} Gain(D,a,t) \nonumber \\
    &= \max_{t \in T_a} (H(D) - \sum_{\lambda \in \{-,+\}} \frac{|D_t^\lambda|}{|D|} H(D_t^\lambda)) \nonumber 
\end{align}</script><p>其中$Gain(D,a,t)$是样本集$D$基于划分点$t$二分后的信息增益，于是就选择使$Gain(D,a,t)$最大化的划分点。<br><strong>注意</strong>：与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为其后代节点的划分属性。例如，在西瓜问题中，在父节点使用了“密度$\leq 0.381$”，在子节点上仍然可以使用“密度$\leq 0.294$”。  </p>
<h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>现实任务中常会遇到不完整样本，即样本的某些属性值缺失，尤其是在属性数目较多的情况下，往往会有大量样本出现缺失值。如果简单地放弃不完整样本，仅使用无缺失值的样本进行学习，显然是对数据信息的极大浪费。<br>在面对缺失值问题时，我们需要解决两个问题：</p>
<ol>
<li>如何在属性值缺失的情况下进行划分属性选择？</li>
<li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？</li>
</ol>
<p>给定训练集$D$和属性$a$，令$\tilde{D}$表示$D$中在属性$a$上没有缺失值的样本子集。<br>问题（1）：假定属性$a$有$V$个可取值${a^1, a^2, \cdots, a^V}$，令$\tilde{D}^v$表示$\tilde{D}$中在属性$a$上取值为$a^v$的样本子集，$\tilde{D}<em>k$表示$\tilde{D}$中属于第$k$类（$k=1,2,\cdots,|\gamma|$）的样本子集，显然有$\tilde{D} = \cup</em>{k=1}^{|\gamma|} \tilde{D}<em>k$，$\tilde{D} = \cup</em>{v=1}^V \tilde{D}^v$，假定为每个样本赋予一个权重$w_{\pmb{x}}$，并定义</p>
<script type="math/tex; mode=display">\begin{align}
    \rho &= \frac{\sum_{\pmb{x} \in \tilde{D}} w_{\pmb{x}}}{\sum_{\pmb{x} \in D} w_{\pmb{x}}} \nonumber \\
    \tilde{p}_k &= \frac{\sum_{\pmb{x} \in \tilde{D}_k} w_{\pmb{x}}}{\sum_{\pmb{x} \in \tilde{D}} w_{\pmb{x}}} \quad (1 \leq k \leq |\gamma|) \nonumber \\
    \tilde{r}_v &= \frac{\sum_{\pmb{x} \in \tilde{D}^v} w_{\pmb{x}}}{\sum_{\pmb{x} \in \tilde{D}} w_{\pmb{x}}} \quad (1 \leq v \leq V) \nonumber
\end{align}</script><p>直观地看，对属性$a$，$\rho$表示无缺失值样本所占的比例，$\tilde{p}<em>k$表示无缺失值样本中第$k$类所占的比例，$\tilde{r}_v$表示无缺失值样本中在属性$a$上取值为$a^v$的样本所占的比例，显然有$\sum</em>{k=1}^{|\gamma|} \tilde{p}<em>k = 1, \sum</em>{v=1}^V \tilde{r}_v = 1$。<br>基于上述定义，可将信息增益的计算式推广为</p>
<script type="math/tex; mode=display">\begin{align}
    Gain(D,a) &= \rho \times Gain(\tilde{D},a) \nonumber \\
    &= \rho \times (H(\tilde{D}) - \sum_{v=1}^V \tilde{r}_v H(\tilde{D}^v)) \nonumber 
\end{align}</script><p>其中</p>
<script type="math/tex; mode=display">H(\tilde{D}) = - \sum_{k=1}^{|\gamma|} \tilde{p}_k \log_2 \tilde{p}_k</script><p>问题（2）：若样本$\pmb{x}$在划分属性$a$上的取值已知，则将$\pmb{x}$划分入与其取值对应的子节点，且样本权值在子节点中保持为$w<em>{\pmb{x}}$。若样本$\pmb{x}$在划分属性$a$上的取值未知，则将$\pmb{x}$同时划入所有子节点，且样本权值在与属性值$a^v$对应的子节点中调整为$\tilde{r}_v · w</em>{\pmb{x}}$。直观来看，就是让同一样本以不同的概率划入到不同的子节点中。<br>C4.5算法就是使用的上述解决方案。</p>
<h2 id="ID3和C4-5算法实现"><a href="#ID3和C4-5算法实现" class="headerlink" title="ID3和C4.5算法实现"></a>ID3和C4.5算法实现</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法的核心是在决策树各个节点上应用<strong>信息增益</strong>准则选择特征，递归地构建决策树。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%916.png" alt="此处输入图片的描述"></p>
<h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>C4.5算法与ID3算法相似，只是在生成过程中，用<strong>信息增益比</strong>来选择特征。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%917.png" alt="此处输入图片的描述"></p>
<h2 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h2><p>分类与回归树（classification and regression tree，CART）是应用广泛的决策树学习方法。CART同样由特征选择、树的生成及剪枝组成，既可以用于分类也可以用于回归。<br>CART是在给定输入随机变量$X$条件下输出随机变量$Y$的条件概率分布的学习方法。CART假设决策树是二叉树，内部节点特征的取值为“是”和“否”，左分支是取值为“是”的分支，右分支是取值为“否”的分支。这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。<br>CART算法分为两步：</p>
<ol>
<li>决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大；</li>
<li>决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，用损失函数最小作为剪枝的标准。</li>
</ol>
<h3 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h3><p>决策树的生成就是递归地构建二叉决策树的过程。对回归树用平方误差最小化准则，对分类树用基尼指数最小化准则。  </p>
<h4 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h4><p>假设$X$与$Y$分别为输入和输出变量，并且$Y$是连续变量，给定训练数据集：</p>
<script type="math/tex; mode=display">D = \{(x_1,y_1), (x_2, y_2), \cdots, (x_N,y_N)\}</script><p>一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,\cdots,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c_m$，于是回归树模型可表示为</p>
<script type="math/tex; mode=display">f(x) = \sum_{m=1}^M c_m I(x \in R_m)</script><p>当输出空间的划分确定时，可以用平方误差$\sum_{x_i \in R_m} (y_i - f(x_i))^2$来表示回归树对于训练数据的预测误差，用平方误差最小的准则求解每个单元上的最优输出值。易知，单元$R_m$上的$c_m$的最优值$\hat{c}_m$是$R_m$上的所有输入实例$x_i$对应的输出$y_i$的均值，即</p>
<script type="math/tex; mode=display">\hat{c}_m = ave(y_i|x_i \in R_m)</script><p>问题是如何对输入空间进行划分。这里采用启发式的方法，选择第$j$个变量$x^{(j)}$和它的取值$s$，作为切分变量（splitting variable）和切分点（splitting point），并定义两个区域：</p>
<script type="math/tex; mode=display">R_1(j,s) = \{x|x^{(j)} \leq s \} \quad R_2(j,s) = \{x| x^{(j)} > s \}</script><p>然后寻找最优切分变量$j$和最优切分点$s$。具体地，求解</p>
<script type="math/tex; mode=display">\min_{j,s} [\min_{c_1} \sum_{x_i \in R_1(j,s)} (y_i - c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i - c_2)^2]</script><p>对固定输入变量$j$可以找到最优切分点$s$。</p>
<script type="math/tex; mode=display">\hat{c}_1 = ave(y_i|x_i \in R_1(j,s)) \quad \hat{c}_2 = ave(y_i|x_i \in R_2(j,s))</script><p>遍历所有输入变量，找到最优切分变量$j$，构成一个对$(j,s)$，依次将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这样生成的回归树通常称为最小二乘回归树（least squares regression tree）。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%918.png" alt="此处输入图片的描述"></p>
<h4 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h4><p>分类树用<strong>基尼指数</strong>选择最优特征，同时决定该特征的最优二值切分点。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%919.png" alt="此处输入图片的描述"></p>
<h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>CART剪枝算法从“完全生长”的决策树的底端减去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：</p>
<ul>
<li>从生成算法产生的决策树$T_0$底端开始剪枝，直到$T_0$的根节点，形成一个子树序列${T_0,T_1,\cdots,T_n}$；</li>
<li>通过交叉验证法在独立的验证集上对子序列进行测试，从中选择最优子树。</li>
</ul>
<p>（1）剪枝，形成一个子树序列<br>在剪枝过程中，计算子树的损失函数：</p>
<script type="math/tex; mode=display">C_\alpha(T) = C(T) + \alpha |T|</script><p>其中，$T$为任意子树，$C(T)$为对训练数据的预测误差（如基尼指数），$|T|$为子树的叶节点个数，$\alpha \geq 0$为参数，$C<em>\alpha (T)$为参数是$\alpha$的子树$T$的整体损失，参数$\alpha$权衡训练数据的拟合程度与模型的复杂度。<br>对于固定的$\alpha$，一定存在是损失函数$C</em>\alpha (T)$最小的子树，将其表示为$T<em>\alpha$。$T</em>\alpha$在损失函数$C<em>\alpha (T)$最小的意义下是最优的。这样的最优子树是唯一的，当$\alpha$较大时，最优子树$T</em>\alpha$偏小；当$\alpha$较小时，最优子树$T<em>\alpha$偏大。极端情况，当$\alpha = 0$时，整体树是最优的，当$\alpha \to \infty$时，根节点组成的单节点树是最优的。<br>可以用递归的方法对树进行剪枝。将$\alpha$从小增大，$0 &lt; \alpha_1 &lt; \cdots &lt; \alpha_n &lt; + \infty$,产生一系列的区间$[\alpha_i, \alpha</em>{i+1}), i=0,1,\cdots, n$；剪枝得到的子树序列对应着区间$ \alpha \in [\alpha<em>i, \alpha</em>{i+1}), \quad i=0,1,\cdots, n$的最优子树序列${T_0,T_1,\cdots,T_n}$，序列中的子树是嵌套的。<br>具体地，从整体树$T_0$开始剪枝。对$T_0$的任意内部节点$t$，以$t$为单节点树的损失函数是</p>
<script type="math/tex; mode=display">C_\alpha (t) = C(t) + \alpha</script><p>以$t$为根节点的子树$T_t$的损失函数是</p>
<script type="math/tex; mode=display">C_\alpha (T_t) = C(T_t) + \alpha |T_i|</script><p>当$\alpha = 0$即$\alpha$充分小时，有不等式</p>
<script type="math/tex; mode=display">C_\alpha (T_t) < C_\alpha (t)</script><p>当$\alpha$增大时，在某一$\alpha$有</p>
<script type="math/tex; mode=display">C_\alpha (T_t) = C_\alpha (t)</script><p>当$\alpha$再增大时，不等式反向。只要$\alpha = \frac{C(t) - C(T_t)}{|T_t| - 1}$，$T_t$与$t$有相同的损失函数值，而$t$的节点少，因此$t$比$T_t$更可取，对$T_t$进行剪枝。<br>为此，对$T_0$中每一个内部节点$t$，计算</p>
<script type="math/tex; mode=display">g(t) = \frac{C(t) - C(T_t)}{|T_t| - 1}</script><p>上式表示剪枝后整体损失函数减小的程度。在$T<em>0$中剪去$g(t)$最小的$T_t$，将得到的子树作为$T_1$，同时将最小的$g(t)$设为$\alpha_1$。$T_1$为区间$[\alpha_1,\alpha_2)$的最优子树。<br>如此剪枝下去，直至得到根节点。在这一过程中，不断地增加$\alpha$的值，产生新的区间。<br>（2）在剪枝得到的子树序列$T_0,T_1,\cdots,T_n$中通过交叉验证选取最优子树$T</em>\alpha$<br>具体地，利用独立的验证数据集，测试子树序列$T<em>0,T_1,\cdots,T_n$中各棵子树的平方误差或基尼指数。平方误差或基尼指数最小的决策树被认为是最优的决策树。在子树序列中，每棵子树$T_0,T_1,\cdots,T_n$都对应于一个参数$\alpha_1, \alpha_2, \cdots, \alpha_n$。所以，当最优子树$T_k$确定时，对应的$\alpha_k$也确定了，即得到最优决策树$T</em>\alpha$。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%9110.png" alt="此处输入图片的描述"></p>
<h2 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h2><p>如果把每个属性视为坐标空间中的一个坐标轴，则$d$个属性描述的样本就对应了$d$维空间中的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同类样本之间的分类边界。决策树所形成的分类边界有一个明显的特点：轴平行（axis-parallel），即它的分类边界由若干个与坐标轴平行的分段组成。这样的分类边界使得学习结果有较好的可解释性，因为每一段划分都直接对应了某个属性取值。但在学习任务的真实分类边界较为复杂时，必须使用很多段划分才能获得较好的近似，决策树也会相当复杂，由于要进行大量的属性测试，预测时间开销也会很大。</p>
<p><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%9111.png" alt="此处输入图片的描述"><br>若能使用斜的划分边界，则决策树模型将大为简化。“多变量决策树”（multivariable decision tree）就能实现这样的斜划分甚至更为复杂划分的决策树。<br>以实现斜划分的多变量决策树为例，在此类决策树中，非叶节点不再是仅对某个属性，而是对属性的线性组合进行测试：每个非叶节点是一个形如$\sum_{i=1}^d w_i a_i = t$的线性分类器，其中$w_i$是属性$a_i$的权重，$w_i$和$t$可在该节点所含的样本集合属性集上学得。与传统的“单变量决策树”不同，在多变量决策树的学习过程中，不是为每个非叶节点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。<br><img src="http://p5vuwy2ht.bkt.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%9112.png" alt="此处输入图片的描述"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="/tags/分类/" rel="tag"># 分类</a>
          
            <a href="/tags/决策树/" rel="tag"># 决策树</a>
          
            <a href="/tags/回归/" rel="tag"># 回归</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/09/机器学习资料（不定时更新）/" rel="next" title="机器学习资料（不定时更新）">
                <i class="fa fa-chevron-left"></i> 机器学习资料（不定时更新）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/18/支持向量机/" rel="prev" title="支持向量机">
                支持向量机 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">KaiQiang Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#决策树"><span class="nav-number">1.</span> <span class="nav-text">决策树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#决策树模型与学习"><span class="nav-number">1.1.</span> <span class="nav-text">决策树模型与学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#决策树模型"><span class="nav-number">1.1.1.</span> <span class="nav-text">决策树模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#决策树学习"><span class="nav-number">1.1.2.</span> <span class="nav-text">决策树学习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征选择"><span class="nav-number">1.2.</span> <span class="nav-text">特征选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#纯度"><span class="nav-number">1.2.1.</span> <span class="nav-text">纯度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息增益"><span class="nav-number">1.2.2.</span> <span class="nav-text">信息增益</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息增益比"><span class="nav-number">1.2.3.</span> <span class="nav-text">信息增益比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基尼指数"><span class="nav-number">1.2.4.</span> <span class="nav-text">基尼指数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#决策树剪枝"><span class="nav-number">1.3.</span> <span class="nav-text">决策树剪枝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续值与缺失值"><span class="nav-number">1.4.</span> <span class="nav-text">连续值与缺失值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连续值处理"><span class="nav-number">1.4.1.</span> <span class="nav-text">连续值处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺失值处理"><span class="nav-number">1.4.2.</span> <span class="nav-text">缺失值处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ID3和C4-5算法实现"><span class="nav-number">1.5.</span> <span class="nav-text">ID3和C4.5算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ID3算法"><span class="nav-number">1.5.1.</span> <span class="nav-text">ID3算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C4-5算法"><span class="nav-number">1.5.2.</span> <span class="nav-text">C4.5算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CART算法"><span class="nav-number">1.6.</span> <span class="nav-text">CART算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CART生成"><span class="nav-number">1.6.1.</span> <span class="nav-text">CART生成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回归树"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">回归树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类树"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">分类树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CART剪枝"><span class="nav-number">1.6.2.</span> <span class="nav-text">CART剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多变量决策树"><span class="nav-number">1.7.</span> <span class="nav-text">多变量决策树</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KaiQiang Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
